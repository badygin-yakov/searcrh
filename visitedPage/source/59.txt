TM Feed Хабрахабр Geektimes Тостер Мой круг Фрилансим Мегапосты: Хабрахабр Публикации Пользователи Хабы Компании Песочница Войти Регистрация HotWaterMusic сегодня в 18:14 Почему "=" означает присваивание? https://www.hillelwayne.com/post/equals-as-assignment/ Программирование, C Перевод Давайте посмотрим на следующий код: a = 1
a = a + 1
print(a) В среде ФП часто критикуют данный момент императивного программирования: «Как так может быть, что a = a + 1? Это всё равно что сказать „1 = 2“. В мутабельном присваивании нет смысла». Здесь мы наблюдаем несовпадение обозначения: «равно» должно обозначать «равенство», когда на практике оно обозначает «присвоить». Я согласен с этой критикой и считаю, что это неудачная нотация. Но также мне известно, что в некоторых языках вместо a = a + 1 пишут выражение a := a + 1. Почему же эта запись не является нормой? На этот вопрос обычно отвечают «потому что так сделано в C». Но это похоже на перекладывание ответственности на кого-то другого: кто из нас знает, почему так сделано в C? Давайте разбираться вместе! Большая четвёрка В начале 1960-ых существовало четыре доминирующих высокоуровневых языка: COBOL, FORTRAN II, ALGOL-60, и LISP. В то время, программисты разбивали присваивание на два класса: инициализацию ( initialization) — когда вы впервые определяете переменную, и переприсвоение ( reassignment) — когда вы вы изменяется значение существующей переменной. Итак, давайте добавим комментарии к нашему примеру на Python и получим следующий код: a = 1 # Инициализация
a = a + 1 # Переприсвоение
print(a) В то время люди не пользовались конкретно этими терминами для обозначения операций, но по сути это было как раз то, что делал каждый программист. В таблице ниже вы можете увидеть, какие из операторов использовались для каждого языка, и как выполнялась проверка на равенство. Язык Инициализация Присваивание Равенство FORTRAN = = .EQ. COBOL INITIALIZE MOVE [1] EQUAL ALGOL N/A := = LISP let set equal В ALGOL не было отдельного оператора для инициализации — вместо этого вы создавали переменную определенного типа и затем использовали оператор для присвоения ей чего-либо. Вы могли написать integer x; x := 5;, но не x := 5;. Единственный язык из списка, который использовал = для присваивания, это FORTRAN — и он выглядит подходящим кандидатом для ответа на наш вопрос. Но мы-то с вами знаем, что C происходит от ALGOL; что, в свою очередь, означает, что по какой-то причине было решено отказаться от оператора присваивания := и изменить значение оператора = с проверки на равенство… ALGOL порождает CPL ALGOL-60, скорее всего, является одним из самых влиятельных языков программирования в истории computer science. Вероятно, что при всём этом он также является одним из самых бесполезных языков. В основной спецификации языка намеренно не было предусмотрено никакой функциональности для ввода/вывода. Вы могли «захардкодить» вводы и измерять выводы, но если вам нужно было сделать с ними что-либо полезное, вам требовалось найти компилятор, который расширял бы базовый язык. ALGOL был спроектирован с целью исследования алгоритмов и поэтому он «ломался», когда вы пытались сделать на нём что-либо ещё. Однако, он оказался настолько «крепким» языком, что другие захотели обобщить его для использования в бизнесе и в промышленности. Первую подобную попытку предприняли Кристофер Страчи и Кембриджский университет. Получившийся в итоге язык CPL добавил к функциональности ALGOL достаточное количество инновационных возможностей, о большей части которых мы в дальнейшем глубоко пожалели. Одной из них было определение с инициализацией, в котором переменная могла быть инициализирована и присвоена в одном выражении. Теперь вместо того, чтобы писать x; x := 5; вы могли просто написать integer x = 5. Просто супер! Но здесь мы переключились с := на =. Это происходит потому, что в CPL было три типа инициализации переменной: = означало инициализацию по значению. ≃ означала инициализацию по ссылке, поэтому если x ≃ y, то переприсваивание x также изменяет y. Но если вы написали x ≃ y + 1 и попробовали переприсвоить x, то программа бы «упала». ≡ означает инициализацию через подстановку, т.е. превращение x в функцию, не принимающую аргументов (niladic function), которая вычисляет правостороннее значение каждый раз, когда её используют. При этом нигде не объясняется, что должно случиться, если вы попробуете переприсвоить x — и я, поверьте, тоже не слишком хочу знать это. Проблема: теперь = использовался и для инициализации, и для равенства. К счастью, на практике в CPL эти варианты использования символа были четко разграничены: если вы где-либо писали =, то было однозначно понятно, что имелось в виду. Всего год спустя Кен Айверсон создаст APL, который станет использовать символ ← для всех видов присваиваний. Поскольку на большинстве клавиатур такой клавиши нет и никогда не было, от него быстро откажется и сам автор — его следующий язык, J, тоже будет использовать для присваиваний символ =: [2]. Однако, APL глубоко повлиял на S, который в свою очередь глубоко повлиял на R — вот почему <- является предпочтительным оператором присваивания в R. CPL порождает BCPL CPL был замечательным языком, обладавшим всего одним небольшим недостатком: ни у кого не получалось написать его реализацию. Несколько человек смогли частично реализовать различные подмножества из его «фич», но этот язык оказался слишком большим и сложным для компиляторов той эпохи. Поэтому неудивительно, что Мартин Ричардс решил избавиться от ненужной сложности ящыка и создал BCPL. Первый компилятор BCPL появился в 1967 году… а первый компилятор CPL — лишь в 1970-м. Среди многих других упрощений оказались и правила «трёх типов инициализации», которые приказали долго жить. Ричардс считал, что выражения-подстановки были вещью узкоспециальной, и их можно было заменить функциями (то же самое, по его мнению, касалось и присваиваний). Поэтому он совместил их всех в простое =, за исключением наименований адресов глобальной памяти, которые использовали :. Как и в случае CPL, = представляло собой проверку на равенство. Для присвоения ( reassignment), он использовал := — аналогично тому, как это сделали CPL и ALGOL. Многие из последовавших после языков также следовали этому соглашению: = для инициализации, := для присваивания, = для равенства. Но в широкие массы это пошло тогда, когда Никлаус Вирт создал Pascal — вот почему сегодня мы называем подобные обозначения «в стиле Pascal». Насколько мне известно, BCPL был также первым «слабо типизированным» языком, поскольку единственным типом данных было машинное слово ( data word) [3]. Это позволило сделать компилятор куда более портабельным за счет потенциального увеличения количества логических ошибок, но Ричардс надеялся на то, что улучшения в процессе и наименования с описанием позволят противостоять этому. Помимо все этого, именно в BCPL впервые появились фигурные скобки с целью определения блоков. BCPL порождает B Кен Томпсон хотел, чтобы BCPL мог выполняться на PDP-7. Несмотря на то, что у BCPL был «компактный компилятор», он всё ещё был в четыре раза больше, чем минимальный объем рабочей памяти на PDP-7 (16 кБ вместо 4 кБ). Поэтому Томпсону требовалось создать новый, более минималистичный язык. Также по личным эстетическим причинам он хотел минимизировать количество символов в исходном коде. Это и повлияло на дизайн языка B сильнее всего; вот почему в нём появились такие операторы, как ++ и --. Если вы оставите в стороне использование поименованных адресов глобальной памяти, в BCPL всегда использовались следующие обозначения: = для инициализации и := для переприсваивания ( reassignment). Томпсон решил, что эти вещи можно совместить в единый токен, который можно использовать для всех видов присваивания, и выбрал =, поскольку оно было короче. Однако, это привнесло некоторую неоднозначность: если x уже был объявлен, то чем было x = y — присваиванием или проверкой на равенство? И это ещё не всё — в некоторых случаях предполагалось, что это это обе операции сразу! Поэтому он был вынужден добавить новый токен == как единую форму выражения смысла «равняется этому». Как выражался сам Томпсон: Поскольку присваивание в типовой программе встречается примерно в два раза чаще, чем сравнение на равенство, уместно было сделать оператор присваивания вполовину короче. За время, прошедшее между появлением BCPL и B, была создана Simula 67, первый объектно-ориентированный язык. Simula последовала соглашениям ALGOL о строгом разделении шагов инициализации и переприсвоения. Алан Кей примерно в это же время начал работу над Smalltalk, который добавил блоки, но последовал такому же синтаксису. Томпсон (к которому присоединился Денис Ритчи) выпустил первую версию B примерно в 1969 году. Так что вплоть до 1971 года (примерно) большинство новых языков использовали для присваивания обозначение :=. B порождает C … остальное – уже история. Хорошо, есть ещё кое-что, о чём стоит рассказать. ML вышел год спустя, и, насколько мне известно, был первым языком, который привлек серьезное внимание к чистым функциям и отсутствию мутаций. Но в нем по-прежнему был спасательный круг в виде ссылочных ячеек ( reference cells), которые можно было переприсваивать новым значениям при помощи оператора :=. Начиная с 1980, мы наблюдаем рост популярности новых императивных языков, ориентированных на корректность — в частности, Eiffel и Ada, оба из которых используют для операции присваивания символ :=. Если посмотреть на всю картину в целом, = никогда не был «естественным выбором» для оператора присваивания. Почти все языки в семейном дереве ALGOL использовали вместо этого для присваивания :=, возможно в силу того, что = было столь тесно ассоциировано с равенством. В наши дни большинство языков использует = поскольку его использует C, и мы можем проследить эту историю до CPL, который представлял собой тот ещё бардак. Примечания 1. В этом месте COBOL становится очень странным. У них есть несколько операторов, которые могут неявно мутировать, вроде ADD TO и COMPUTE. COBOL — плохой язык. 2. Мне нравится думать, что это было своеобразным приколом над :=, хотя на самом деле этот оператор согласован с остальными частями языка, который использует . и : как суффиксы глаголов. 3. Позже в BCPL добавят ключевое слово для типа с плавающей запятой. И когда я говорю «позже», я имею в виду 2018 год. Метки: история создания Добавить метки Пометьте публикацию своими метками Метки необходимо разделять запятой. Например: php, javascript, андронный коллайдер, задача трех тел Сохранить AdBlock похитил этот баннер, но баннеры не зубы — отрастут Подробнее Реклама Читают сейчас Почему в 2018 году я использую метод разработки, которому уже 30 лет 12,9k 19 Firefox Gecko, «который мы потеряли» 5,8k 71 Как пользователи учат Яндекс предупреждать о телефонном спаме 9k 96 TDD ошибочно? 2,3k 2 Почему "=" означает присваивание? 4,8k 8 Приложения, достигшие самосознания: автоматизированная диагностика в продакшне 1,5k 0 AdBlock похитил этот баннер, но баннеры не зубы — отрастут Подробнее Реклама +28 15 4,8k 8 Выберите рекомендации для отправки автору: Указан только блог Орфографические ошибки Пунктуационные ошибки Отступы Текст-простыня Короткие предложения Смайлики Много форматирования Картинки Ссылки Оформление кода Рекламный характер Отправить Нарушение Опишите суть нарушения Отправить 215,7 Карма 199,2 Рейтинг 90 Подписчики Владимир Маслов HotWaterMusic Разработчик и автор Поделиться публикацией Похожие публикации 11 июля 2013 в 19:09 История создания BioForge +32 23,8k 36 15 15 мая 2013 в 00:38 История создания Diablo +122 86,6k 202 161 13 апреля 2011 в 13:10 История создания инструмента прототипирования. Часть II +11 11,2k 16 38 Вакансии Frontend developer (фронтенд-разработчик) MyWed Рязань Полный рабочий день от 60 000 до 70 000 Front-end разработчик на Vuejs 2.x Остров Сокровищ Полный рабочий день от 90 000 до 128 000 Разработчик Sharepoint Stecpoint Полный рабочий день от 120 000 iOS Developer Media Target LLC Москва Полный рабочий день до 180 000 Программист-разработчик С/С++ EME Москва Полный рабочий день от 70 000 до 100 000 Все вакансии Разместить вакансию AdBlock похитил этот баннер, но баннеры не зубы — отрастут Подробнее Реклама Комментарии 8 datacompboy 11.04.18 в 18:48 +7 В переводе упущена отличнейшая сноска: «BCPL later adding a floating point keyword. And when I say “later”, I mean in 2018.» HotWaterMusic 11.04.18 в 19:09 +1 Просто отлично. Спасибо, добавил! AnutaU 11.04.18 в 19:44 +2 Напомнило историю про современные технические достижения и ширину крупа лошади. juray 11.04.18 в 20:10 +1 Самая логичная запись присваивания — в ранних версиях Рапиры: Х+Y -> Х она отражает тот факт, что сначала вычисляется выражение и уже потом результат присваивается переменной. Desprit 11.04.18 в 20:32 0 С одной стороны — да, но тогда будет сложнее искать инициализированные переменные в коде, ведь конец строки везде разный. Куда проще пробежаться глазами по одной линии. Samouvazhektra 11.04.18 в 20:13 0 если воспринимать "a" как букву/название то действительно может показаться что a=a+1 — странно, но если сместиться на парадигму что "a" это у нас грубо говоря именнованый акцесс к памяти то a=1 //записать в область памяти с меткой а значение 1, a=a+1 //записать в область памяти с меткой а увеличнное на 1 предыдущее значение… velvetcat 11.04.18 в 20:43 0 Тоже думаю, что проблема преувеличена, и иммутабельность здесь не при чем. Platon_msk 11.04.18 в 22:28 0 Проблема высосана из мизинца левой ноги. x = 2y + 1 в школе ни у кого не вызывало вопросов. Не можешь запомнить нотацию языка, не программируй на нём. Только полноправные пользователи могут оставлять комментарии. Войдите, пожалуйста. Что обсуждают Сейчас Вчера Неделя Игра Snake в 93 байта 13,7k 21 Фреймворк для бессерверных приложений в AWS 1,9k 6 Для чего программисту Continuous Integration и с чего начинать 14,9k 42 Хакеры атаковали пользователей криптобиржи Poloniex с помощью поддельного мобильного приложения 667 2 Как пользователи учат Яндекс предупреждать о телефонном спаме 9k 96 Диванный вице-президент: как я работаю директором по продуктам на полной удалёнке 10,5k 132 Как пользователи учат Яндекс предупреждать о телефонном спаме 9k 96 Firefox Gecko, «который мы потеряли» 5,8k 71 Для чего программисту Continuous Integration и с чего начинать 14,9k 42 Применение сверточных нейронных сетей для задач NLP 10,5k 21 Как специалисты Google Adwords помогли мне выбросить 150 000 грн (около $6000) за месяц или почему я больше не буду… 49k 251 Мессенджеры, пора делать следующий шаг 30,2k 220 Почему я не подписываю соглашения о неконкуренции 32,7k 166 Диванный вице-президент: как я работаю директором по продуктам на полной удалёнке 10,5k 132 Осторожнее с копипастом: фингерпринтинг текста непечатаемыми символами 30,1k 93 Самое читаемое Сутки Неделя Месяц Почему в 2018 году я использую метод разработки, которому уже 30 лет +24 12,9k 56 19 История про блокчейн и немного про биткойны +24 10,8k 65 18 Для чего программисту Continuous Integration и с чего начинать +42 14,9k 220 42 Как пользователи учат Яндекс предупреждать о телефонном спаме +48 9k 18 96 Firefox Gecko, «который мы потеряли» +10 5,8k 15 71 Как специалисты Google Adwords помогли мне выбросить 150 000 грн (около $6000) за месяц или почему я больше не буду… +86 49k 123 251 Как я за 9 месяцев превратился из неофита в разработчика ПО без отрыва от основной работы +31 38k 305 38 Почему я не подписываю соглашения о неконкуренции +87 32,7k 84 166 Конференция DEFCON 23. «Как я сбивал назойливый дрон соседского ребёнка». Майкл Робинсон +60 30,7k 135 38 Мессенджеры, пора делать следующий шаг +18 30,2k 83 220 Как уже снова не получить телефон (почти) любой красотки в Москве, или интересная особенность MT_FREE +129 163k 260 101 Мы нашли крупную компанию, которая 5 лет не занималась информационной безопасностью, и она ещё жива +30 79k 119 97 Как Red Hat убила свой главный продукт и стала многомиллиардной корпорацией +89 67,4k 105 68 Дискредитация специалистов или современные собеседования +77 61,6k 153 675 [BugBounty] Раскрытие 5 миллионов ссылок в приватные чаты Telegram и возможность редактирования любой статьи telegra.ph +116 58k 172 66 Интересные публикации Хабрахабр Geektimes Обнаружена уязвимость в панели управления хостингом Vesta CP +5 222 3 0 Роскомнадзор продолжает уничтожать Интернет: настала очередь Google GT +9 4k 4 12 Имитация левитации воды на Ардуино GT +18 2,9k 14 16 Охота на Dofoil с помощью Windows Defender ATP +10 442 2 1 Лишать гарантии за оторванную наклейку или пломбу — незаконно GT +16 3,8k 7 1 TDD ошибочно? +22 2,3k 28 2 Журналисты нашли в Москве 11 пунктов обмена криптовалюты и 4 биткоин-банкомата +7 1,6k 3 2 JNI: Подружим Java и C++ +6 1,4k 26 4 Новый апдейт iOS сделал неоригинальные экраны «восьмерок» неработоспособными GT +24 10,3k 7 37 Apple заставят заплатить $500 млн патентному троллю GT +8 5,6k 3 6 AdBlock похитил этот баннер, но баннеры не зубы — отрастут Подробнее Реклама Аккаунт Войти Регистрация Разделы Публикации Хабы Компании Пользователи Песочница Информация Правила Помощь Документация Соглашение Конфиденциальность Услуги Реклама Тарифы Контент Семинары Приложения © 2006 – 2018 «TM» О сайте Служба поддержки Мобильная версия
